name: Frontend Documentation

on:
  push:
    branches: [ '*']
    paths:
      - 'bulak-smart-connect-js/src/**'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build-storybook:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: 'bulak-smart-connect-js/package-lock.json'
      
      - name: Install dependencies
        run: |
          cd bulak-smart-connect-js
          npm ci
          
          # Install Storybook with the specific framework integration package
          npm install --save-dev @storybook/react @storybook/react-vite @storybook/addon-essentials @storybook/addon-links @storybook/addon-interactions @storybook/blocks @vitejs/plugin-react-swc
          
      - name: Setup Storybook with enhanced component detection
        run: |
          cd bulak-smart-connect-js
          
          # Create .storybook directory if it doesn't exist
          mkdir -p .storybook
          
          # Create main.js configuration using CommonJS module syntax
          cat > .storybook/main.js << 'EOF'
          /** @type {import('@storybook/react-vite').StorybookConfig} */
          const config = {
            stories: ['../src/**/*.stories.@(js|jsx)'],
            addons: [
              '@storybook/addon-links',
              '@storybook/addon-essentials',
              '@storybook/addon-interactions',
            ],
            framework: {
              name: '@storybook/react-vite',
              options: {},
            },
            docs: {
              autodocs: true,
            },
            core: {
              disableTelemetry: true
            },
          };
          
          module.exports = config;
          EOF
          
          # Create preview.js WITHOUT JSX syntax
          cat > .storybook/preview.js << 'EOF'
          import React from 'react';
          import { BrowserRouter } from 'react-router-dom';
          
          /** @type {import('@storybook/react').Preview} */
          const preview = {
            parameters: {
              actions: { argTypesRegex: "^on[A-Z].*" },
              controls: {
                matchers: {
                  color: /(background|color)$/i,
                  date: /Date$/,
                },
              },
            },
            decorators: [
              (Story) => {
                return React.createElement(
                  BrowserRouter,
                  null,
                  React.createElement(Story, null)
                );
              }
            ],
          };
          
          module.exports = preview;
          EOF
          
      - name: Setup Storybook with better debugging
        run: |
          cd bulak-smart-connect-js
          
          # Create story generator script with better debug logging
          cat > generate-stories.mjs << 'EOF'
          import fs from 'fs/promises';
          import path from 'path';
          import { fileURLToPath } from 'url';
          import { dirname } from 'path';
          import * as globModule from 'glob';
          import { promisify } from 'util';
          
          const glob = globModule.default || globModule.glob || globModule;
          const globAsync = promisify(glob);
          const __filename = fileURLToPath(import.meta.url);
          const __dirname = dirname(__filename);
          
          // Configuration
          const SRC_DIR = './src';
          
          async function generateStories() {
            try {
              console.log(`Looking for components in ${path.resolve(SRC_DIR)}`);
              
              // Debug directory structure
              try {
                const dirs = await fs.readdir(SRC_DIR);
                console.log(`Found directories in src: ${dirs.join(', ')}`);
              } catch (error) {
                console.error(`Error reading src directory: ${error.message}`);
              }
              
              // More comprehensive component search
              const ALL_EXTENSIONS = ['.jsx', '.js'];
              const allFiles = await globAsync(`${SRC_DIR}/**/*{${ALL_EXTENSIONS.join(',')}}`, {
                ignore: ['**/node_modules/**', '**/*.stories.*', '**/*.test.*', '**/*.spec.*']
              });
              
              console.log(`Found ${allFiles.length} total JS/JSX files`);
              
              // Create mocks directory if it doesn't exist
              const mocksDir = path.join(SRC_DIR, '__mocks__');
              await fs.mkdir(mocksDir, { recursive: true });
              
              // Create AuthContext mock
              const authContextMockPath = path.join(mocksDir, 'authContext.js');
              const authContextMock = `
          // Mock AuthContext for Storybook
          export const useAuth = () => ({
            isAuthenticated: true,
            user: {
              name: 'John Doe',
              email: 'john.doe@example.com',
              roles: ['admin'],
              defaultRole: 'admin'
            },
            loading: false,
            error: null,
            login: () => Promise.resolve({ success: true }),
            logout: () => {},
            hasRole: (role) => ['admin', 'staff', 'citizen'].includes(role),
            hasAnyRole: (roles) => roles.some(role => ['admin', 'staff', 'citizen'].includes(role)),
            isAdmin: true,
            isStaff: true,
            isCitizen: true
          });
          `;
              await fs.writeFile(authContextMockPath, authContextMock);
              
              let componentsFound = 0;
              let storiesGenerated = 0;
              
              // Process 100 files at a time for better manageability
              const filesToProcess = allFiles.slice(0, 100);
              console.log(`Processing first ${filesToProcess.length} files`);
              
              // Loop through files
              for (const filePath of filesToProcess) {
                try {
                  const content = await fs.readFile(filePath, 'utf8');
                  const fileName = path.basename(filePath, path.extname(filePath));
                  
                  // Improved component detection - more lenient
                  const hasExport = content.includes('export ') || content.includes('export default');
                  const hasReactImport = content.includes('import React') || content.includes('from "react"') || content.includes("from 'react");
                  const hasJSXSyntax = content.includes('<') && content.includes('/>') || content.includes('</');
                  
                  if ((hasExport && hasReactImport) || (hasExport && hasJSXSyntax)) {
                    componentsFound++;
                    const relativePath = path.relative(SRC_DIR, path.dirname(filePath));
                    console.log(`Found component: ${fileName} in ${relativePath}`);
                    
                    // Skip context files
                    if (content.includes('createContext') || 
                        fileName.toLowerCase().includes('context') || 
                        fileName.toLowerCase().includes('provider')) {
                      console.log(`Skipping context file: ${fileName}`);
                      continue;
                    }
                    
                    // Create story path
                    const storyFilePath = path.join(
                      path.dirname(filePath),
                      `${fileName}.stories.jsx`
                    );
                    
                    // Skip if exists
                    try {
                      await fs.access(storyFilePath);
                      console.log(`Story already exists for ${fileName}, skipping`);
                      continue;
                    } catch (error) {
                      // File doesn't exist, continue
                    }
                    
                    // Determine category
                    const category = relativePath.split(path.sep)[0] || 'General';
                    
                    // Generate story file
                    const isDefaultExport = content.includes(`export default ${fileName}`) || 
                                          content.includes('export default function') ||
                                          content.includes('export default class');
                    
                    const importStatement = isDefaultExport
                      ? `import ${fileName} from './${fileName}';`
                      : `import { ${fileName} } from './${fileName}';`;
                    
                    const storyTemplate = `import React from 'react';
          ${importStatement}
          
          // Optional: import mock auth context if needed
          // import { useAuth } from '../__mocks__/authContext';
          
          export default {
            title: '${category}/${fileName}',
            component: ${fileName},
            parameters: {
              componentSubtitle: 'Component from ${relativePath}'
            },
            decorators: [
              (Story) => React.createElement('div', 
                { style: { padding: '1rem', maxWidth: '800px', margin: '0 auto' } },
                React.createElement(Story, null)
              )
            ]
          };
          
          export const Default = {
            args: {
              // Add default props here
            }
          };`;
                    
                    await fs.writeFile(storyFilePath, storyTemplate);
                    console.log(`âœ“ Created story for ${fileName}`);
                    storiesGenerated++;
                    
                  }
                } catch (error) {
                  console.log(`Error processing ${filePath}: ${error.message}`);
                }
              }
              
              // Always create a dummy story as fallback
              if (storiesGenerated === 0) {
                const dummyStoryPath = path.join(SRC_DIR, 'dummy.stories.jsx');
                const dummyStory = `
          import React from 'react';
          
          const Dummy = () => <div>This is a placeholder component to ensure Storybook loads correctly</div>;
          
          export default {
            title: 'Placeholder/Dummy',
            component: Dummy,
          };
          
          export const Default = {};
          `;
                await fs.writeFile(dummyStoryPath, dummyStory);
                console.log('Created dummy story for fallback');
                storiesGenerated = 1;
              }
              
              console.log(`âœ… Story generation complete!`);
              console.log(`Found ${componentsFound} components`);
              console.log(`Generated ${storiesGenerated} stories`);
              
            } catch (error) {
              console.error(`Error in story generation: ${error.message}`);
              console.error(error.stack);
              process.exit(1);
            }
          }
          
          generateStories();
          EOF
          
          # Install necessary packages
          npm install --no-save glob
          
          # Run generator with better debugging
          node generate-stories.mjs

      - name: Setup Storybook with more aggressive component detection
        run: |
          cd bulak-smart-connect-js
          
          # Create a more aggressive story generator script
          cat > generate-stories.mjs << 'EOF'
          import fs from 'fs/promises';
          import path from 'path';
          import { fileURLToPath } from 'url';
          import { dirname } from 'path';
          import * as globModule from 'glob';
          import { promisify } from 'util';
          
          const glob = globModule.default || globModule.glob || globModule;
          const globAsync = promisify(glob);
          const __filename = fileURLToPath(import.meta.url);
          const __dirname = dirname(__filename);
          
          // Configuration
          const SRC_DIR = './src';
          
          // Function to recursively find files with given extensions
          async function findFiles(dir, extensions) {
            let results = [];
            try {
              const items = await fs.readdir(dir, { withFileTypes: true });
              
              for (const item of items) {
                const fullPath = path.join(dir, item.name);
                
                if (item.isDirectory()) {
                  // Skip node_modules and test directories
                  if (item.name === 'node_modules' || item.name === '__tests__') continue;
                  results = results.concat(await findFiles(fullPath, extensions));
                } else if (extensions.some(ext => item.name.endsWith(ext)) && 
                          !item.name.includes('.stories.') && 
                          !item.name.includes('.test.') && 
                          !item.name.includes('.spec.')) {
                  results.push(fullPath);
                }
              }
            } catch (err) {
              console.error(`Error reading directory ${dir}: ${err.message}`);
            }
            
            return results;
          }
          
          async function generateStories() {
            try {
              console.log(`Looking for components in ${path.resolve(SRC_DIR)}`);
              
              // Find JS/JSX files using recursive function instead of glob
              console.log("Finding JS/JSX files recursively...");
              const ALL_EXTENSIONS = ['.jsx', '.js'];
              const allFiles = await findFiles(SRC_DIR, ALL_EXTENSIONS);
              
              console.log(`Found ${allFiles.length} total JS/JSX files`);
              if (allFiles.length > 0) {
                console.log("Sample files found:");
                allFiles.slice(0, 5).forEach(file => console.log(` - ${file}`));
              }
              
              // Create mocks directory if it doesn't exist
              const mocksDir = path.join(SRC_DIR, '__mocks__');
              await fs.mkdir(mocksDir, { recursive: true });
              
              // Create AuthContext mock
              const authContextMockPath = path.join(mocksDir, 'authContext.js');
              const authContextMock = `
          // Mock AuthContext for Storybook
          export const useAuth = () => ({
            isAuthenticated: true,
            user: { name: 'John Doe', email: 'john.doe@example.com', roles: ['admin'] },
            login: () => Promise.resolve({ success: true }),
            logout: () => {},
            hasRole: () => true,
            isAdmin: true
          });
          `;
              await fs.writeFile(authContextMockPath, authContextMock);
              
              let componentsFound = 0;
              let storiesGenerated = 0;
              
              // Target specific component directories first
              const targetDirs = [
                'AdminBulakSmartConnect',
                'LandingPageComponents',
                'LogInComponents',
                'NavigationComponents',
                'UserBulakSmartConnect',
                'components'
              ];
              
              // Proceed with component identification - prioritize specific files
              const priorityFiles = allFiles.filter(file => {
                const relativePath = path.relative(SRC_DIR, file);
                return targetDirs.some(dir => relativePath.startsWith(dir)) || 
                       path.basename(file) === 'App.jsx';
              });
              
              console.log(`Found ${priorityFiles.length} priority component files to process`);
              
              // Process priority files first
              for (const filePath of priorityFiles) {
                try {
                  const content = await fs.readFile(filePath, 'utf8');
                  const fileName = path.basename(filePath, path.extname(filePath));
                  
                  // Skip obvious non-components
                  if (fileName.toLowerCase().includes('context') || 
                      fileName.toLowerCase().includes('provider') ||
                      fileName.toLowerCase().includes('service') ||
                      fileName.toLowerCase().includes('utils') ||
                      fileName.toLowerCase().includes('constants')) {
                    console.log(`Skipping utility file: ${fileName}`);
                    continue;
                  }
                  
                  componentsFound++;
                  const relativePath = path.relative(SRC_DIR, path.dirname(filePath));
                  console.log(`Processing component: ${fileName} in ${relativePath}`);
                  
                  // Create story path
                  const storyFilePath = path.join(
                    path.dirname(filePath),
                    `${fileName}.stories.jsx`
                  );
                  
                  // Skip if exists
                  try {
                    await fs.access(storyFilePath);
                    console.log(`Story already exists for ${fileName}, skipping`);
                    continue;
                  } catch (error) {
                    // File doesn't exist, continue
                  }
                  
                  // Determine category
                  let category = relativePath.split(path.sep)[0] || 'General';
                  
                  // Generate story file
                  const storyTemplate = `import React from 'react';
          import ${fileName} from './${fileName}';
          
          export default {
            title: '${category}/${fileName}',
            component: ${fileName},
            parameters: {
              componentSubtitle: 'Component from ${relativePath}'
            }
          };
          
          export const Default = {
            args: {}
          };`;
                  
                  await fs.writeFile(storyFilePath, storyTemplate);
                  console.log(`âœ“ Created story for ${fileName}`);
                  storiesGenerated++;
                } catch (error) {
                  console.log(`Error processing ${filePath}: ${error.message}`);
                }
              }
              
              // Always create a dummy story as fallback
              if (storiesGenerated === 0) {
                const dummyStoryPath = path.join(SRC_DIR, 'dummy.stories.jsx');
                const dummyStory = `
          import React from 'react';
          
          const Dummy = () => <div>This is a placeholder component to ensure Storybook loads correctly</div>;
          
          export default {
            title: 'Placeholder/Dummy',
            component: Dummy,
          };
          
          export const Default = {};
          `;
                await fs.writeFile(dummyStoryPath, dummyStory);
                console.log('Created dummy story for fallback');
                storiesGenerated = 1;
              }
              
              console.log(`âœ… Story generation complete!`);
              console.log(`Found ${componentsFound} components`);
              console.log(`Generated ${storiesGenerated} stories`);
              
            } catch (error) {
              console.error(`Error in story generation: ${error.message}`);
              console.error(error.stack);
              process.exit(1);
            }
          }
          
          generateStories();
          EOF
          
          # Install necessary packages
          npm install --no-save glob
          
          # Run generator with better debugging
          node generate-stories.mjs

      - name: Setup Storybook with improved component detection
        run: |
          cd bulak-smart-connect-js
          
          # Create story generator script that properly filters utility files
          cat > generate-stories.mjs << 'EOF'
          import fs from 'fs/promises';
          import path from 'path';
          import { fileURLToPath } from 'url';
          import { dirname } from 'path';
          import * as globModule from 'glob';
          import { promisify } from 'util';
          
          const glob = globModule.default || globModule.glob || globModule;
          const globAsync = promisify(glob);
          const __filename = fileURLToPath(import.meta.url);
          const __dirname = dirname(__filename);
          
          // Configuration
          const SRC_DIR = './src';
          
          async function generateStories() {
            try {
              console.log(`Looking for components in ${path.resolve(SRC_DIR)}`);
              
              // Find files with JSX/JS extensions
              const ALL_EXTENSIONS = ['.jsx', '.js'];
              const allFiles = await globAsync(`${SRC_DIR}/**/*{${ALL_EXTENSIONS.join(',')}}`, {
                ignore: ['**/node_modules/**', '**/*.stories.*', '**/*.test.*', '**/*.spec.*']
              });
              
              console.log(`Found ${allFiles.length} total JS/JSX files`);
              
              // Filter files that are likely to be components
              const componentFiles = allFiles.filter(file => {
                // Prefer .jsx files which are almost always components
                const ext = path.extname(file);
                const fileName = path.basename(file, ext);
                
                // Skip utility files, services, and helper files
                if (ext === '.js' && (
                  fileName.includes('Service') || 
                  fileName.includes('Utils') || 
                  fileName.includes('Helper') ||
                  fileName.includes('Info') ||
                  fileName.includes('Data') ||
                  fileName === 'api' ||
                  fileName === 'context'
                )) {
                  return false;
                }
                
                return true;
              });
              
              console.log(`Filtered to ${componentFiles.length} potential component files`);
              
              // Create mocks directory if it doesn't exist
              const mocksDir = path.join(SRC_DIR, '__mocks__');
              await fs.mkdir(mocksDir, { recursive: true });
              
              // Create AuthContext mock (same as before)
              const authContextMockPath = path.join(mocksDir, 'authContext.js');
              const authContextMock = `
          // Mock AuthContext for Storybook
          export const useAuth = () => ({
            isAuthenticated: true,
            user: { name: 'John Doe', email: 'john.doe@example.com', roles: ['admin'] },
            login: () => Promise.resolve({ success: true }),
            logout: () => {},
            hasRole: () => true,
            isAdmin: true
          });
          `;
              await fs.writeFile(authContextMockPath, authContextMock);
              
              let componentsFound = 0;
              let storiesGenerated = 0;
              
              // Process each potential component file
              for (const filePath of componentFiles) {
                try {
                  // Read file content
                  const content = await fs.readFile(filePath, 'utf8');
                  const fileExt = path.extname(filePath);
                  const fileName = path.basename(filePath, fileExt);
                  
                  // More aggressive component detection for JS files
                  if (fileExt === '.js') {
                    // For .js files, only create stories if they look like React components
                    const hasReactComponent = (
                      content.includes('import React') || 
                      content.includes('from "react"') || 
                      content.includes("from 'react'")
                    ) && (
                      content.includes('function') && content.includes('return') && 
                      (content.includes('<') && content.includes('/>') || content.includes('</'))
                    );
                    
                    if (!hasReactComponent) {
                      console.log(`Skipping non-component JS file: ${fileName}`);
                      continue;
                    }
                  }
                  
                  // Skip obvious non-components
                  if (fileName.toLowerCase().includes('context') || 
                      fileName.toLowerCase().includes('provider') ||
                      fileName.toLowerCase().includes('service') ||
                      fileName.toLowerCase().includes('utils') ||
                      fileName.toLowerCase().includes('constants')) {
                    console.log(`Skipping utility file: ${fileName}`);
                    continue;
                  }
                  
                  // Check if the file has a React component signature
                  const isComponent = (
                    content.includes('export default') && (
                      content.includes('function') ||
                      content.includes('class') ||
                      content.includes('const')
                    ) && (
                      content.includes('return') || content.includes('render')
                    )
                  );
                  
                  if (!isComponent && fileExt === '.js') {
                    console.log(`Skipping non-component file: ${fileName}`);
                    continue;
                  }
                  
                  componentsFound++;
                  const relativePath = path.relative(SRC_DIR, path.dirname(filePath));
                  console.log(`Processing component: ${fileName} in ${relativePath}`);
                  
                  // Create story path
                  const storyFilePath = path.join(
                    path.dirname(filePath),
                    `${fileName}.stories.jsx`
                  );
                  
                  // Skip if exists (as before)
                  try {
                    await fs.access(storyFilePath);
                    console.log(`Story already exists for ${fileName}, skipping`);
                    continue;
                  } catch (error) {
                    // File doesn't exist, continue
                  }
                  
                  // Determine import type
                  const hasDefaultExport = content.includes(`export default ${fileName}`) || 
                                         content.includes('export default function') ||
                                         content.includes('export default class') ||
                                         content.includes('export default (') ||
                                         content.includes('export default const');
                  
                  // For .js files, use a different import approach that works with both named and default exports
                  let importStatement;
                  if (fileExt === '.js') {
                    importStatement = `// For JS files, dynamically import the component\nconst ${fileName} = () => null; // Placeholder to prevent errors`;
                  } else {
                    importStatement = hasDefaultExport
                      ? `import ${fileName} from './${fileName}';`
                      : `import { ${fileName} } from './${fileName}';`;
                  }
                  
                  // Generate story file with safe imports
                  const storyTemplate = `import React from 'react';
          ${importStatement}
          
          export default {
            title: '${relativePath}/${fileName}',
            component: ${fileName},
            parameters: {
              componentSubtitle: 'Component from ${relativePath}'
            }
          };
          
          export const Default = {
            args: {},
            parameters: {
              docs: {
                description: {
                  component: 'This component is from ${relativePath}/${fileName}'
                }
              }
            }
          };`;
                  
                  await fs.writeFile(storyFilePath, storyTemplate);
                  console.log(`âœ“ Created story for ${fileName}`);
                  storiesGenerated++;
                  
                } catch (error) {
                  console.log(`Error processing ${filePath}: ${error.message}`);
                }
              }
              
              // Always create a dummy story as fallback
              if (storiesGenerated === 0) {
                const dummyStoryPath = path.join(SRC_DIR, 'dummy.stories.jsx');
                const dummyStory = `
          import React from 'react';
          
          const Dummy = () => <div>This is a placeholder component to ensure Storybook loads correctly</div>;
          
          export default {
            title: 'Placeholder/Dummy',
            component: Dummy,
          };
          
          export const Default = {};
          `;
                await fs.writeFile(dummyStoryPath, dummyStory);
                console.log('Created dummy story for fallback');
                storiesGenerated = 1;
              }
              
              console.log(`âœ… Story generation complete!`);
              console.log(`Found ${componentsFound} components`);
              console.log(`Generated ${storiesGenerated} stories`);
              
            } catch (error) {
              console.error(`Error in story generation: ${error.message}`);
              console.error(error.stack);
              process.exit(1);
            }
          }
          
          generateStories();
          EOF
          
          # Install necessary packages
          npm install --no-save glob
          
          # Run generator with better debugging
          node generate-stories.mjs

      - name: Setup Storybook with utility file handling
        run: |
          cd bulak-smart-connect-js
          
          # Create story generator script with better utility file filtering
          cat > generate-stories.mjs << 'EOF'
          import fs from 'fs/promises';
          import path from 'path';
          import { fileURLToPath } from 'url';
          import { dirname } from 'path';
          import * as globModule from 'glob';
          import { promisify } from 'util';
          
          const glob = globModule.default || globModule.glob || globModule;
          const globAsync = promisify(glob);
          const __filename = fileURLToPath(import.meta.url);
          const __dirname = dirname(__filename);
          
          // Configuration
          const SRC_DIR = './src';
          
          // Lists of patterns to identify utility files (not components)
          const UTILITY_PATTERNS = [
            'api.js', 'service', 'util', 'helper', 'context', 'provider', 
            'store', 'reducer', 'action', 'constant', 'config', 'hook',
            'data.js', '.data.js', 'mock', 'Info.js', 'manager'
          ];
          
          // Function to check if a file is likely a utility file
          const isUtilityFile = (filePath, content) => {
            const fileName = path.basename(filePath).toLowerCase();
            const ext = path.extname(filePath).toLowerCase();
            
            // Check filename patterns for utility files
            if (UTILITY_PATTERNS.some(pattern => fileName.includes(pattern.toLowerCase()))) {
              return true;
            }
            
            // For JS files, check if they look like modules rather than components
            if (ext === '.js') {
              // If it has multiple exports but no JSX, it's likely a utility file
              const hasMultipleExports = (content.match(/export\s+(const|function|let|var|class)/g) || []).length > 1;
              const hasJSX = content.includes('<') && (content.includes('/>') || content.includes('</'));
              
              if (hasMultipleExports && !hasJSX) {
                return true;
              }
              
              // Check for common utility exports
              if (content.includes('export function') || 
                  content.includes('export const') && !content.includes('return (') && !content.includes('return <')) {
                return true;
              }
            }
            
            return false;
          };
          
          async function generateStories() {
            try {
              console.log(`Looking for components in ${path.resolve(SRC_DIR)}`);
              
              // Debug directory structure
              try {
                const dirs = await fs.readdir(SRC_DIR);
                console.log(`Found directories in src: ${dirs.join(', ')}`);
              } catch (error) {
                console.error(`Error reading src directory: ${error.message}`);
              }
              
              // Find all potential files
              const ALL_EXTENSIONS = ['.jsx', '.js'];
              const allFiles = await globAsync(`${SRC_DIR}/**/*{${ALL_EXTENSIONS.join(',')}}`, {
                ignore: ['**/node_modules/**', '**/*.stories.*', '**/*.test.*', '**/*.spec.*']
              });
              
              console.log(`Found ${allFiles.length} total JS/JSX files before filtering`);
              
              // Filter files more aggressively
              const componentFiles = [];
              const skippedFiles = [];
              
              for (const file of allFiles) {
                try {
                  const content = await fs.readFile(file, 'utf8');
                  
                  // Skip utility files
                  if (isUtilityFile(file, content)) {
                    skippedFiles.push(path.basename(file));
                    continue;
                  }
                  
                  // Check for component characteristics
                  const hasExport = content.includes('export default') || content.includes('export ');
                  const hasJSX = content.includes('<') && (content.includes('/>') || content.includes('</'));
                  const hasReactImport = content.includes('import React') || 
                                        content.includes('from "react"') || 
                                        content.includes("from 'react");
                  
                  // Only include files that look like React components
                  if (hasExport && (hasJSX || hasReactImport)) {
                    componentFiles.push(file);
                  } else {
                    skippedFiles.push(path.basename(file));
                  }
                } catch (err) {
                  console.log(`Error reading file ${file}: ${err.message}`);
                }
              }
              
              console.log(`Filtered to ${componentFiles.length} component files`);
              console.log(`Skipped ${skippedFiles.length} non-component files including: ${skippedFiles.slice(0, 10).join(', ')}${skippedFiles.length > 10 ? '...' : ''}`);
              
              // Create mocks directory and AuthContext mock (as before)
              const mocksDir = path.join(SRC_DIR, '__mocks__');
              await fs.mkdir(mocksDir, { recursive: true });
              
              const authContextMockPath = path.join(mocksDir, 'authContext.js');
              const authContextMock = `
          // Mock AuthContext for Storybook
          export const useAuth = () => ({
            isAuthenticated: true,
            user: {
              name: 'John Doe',
              email: 'john.doe@example.com',
              roles: ['admin'],
              defaultRole: 'admin'
            },
            loading: false,
            error: null,
            login: () => Promise.resolve({ success: true }),
            logout: () => {},
            hasRole: (role) => ['admin', 'staff', 'citizen'].includes(role),
            hasAnyRole: (roles) => roles.some(role => ['admin', 'staff', 'citizen'].includes(role)),
            isAdmin: true,
            isStaff: true,
            isCitizen: true
          });
          `;
              await fs.writeFile(authContextMockPath, authContextMock);
              
              let storiesGenerated = 0;
              
              // Process component files
              for (const filePath of componentFiles) {
                try {
                  const content = await fs.readFile(filePath, 'utf8');
                  const fileName = path.basename(filePath, path.extname(filePath));
                  const relativePath = path.relative(SRC_DIR, path.dirname(filePath));
                  
                  console.log(`Creating story for: ${fileName} in ${relativePath}`);
                  
                  // Create story path with .jsx extension for all stories
                  const storyFilePath = path.join(
                    path.dirname(filePath),
                    `${fileName}.stories.jsx`
                  );
                  
                  // Skip if exists
                  try {
                    await fs.access(storyFilePath);
                    console.log(`Story already exists for ${fileName}, skipping`);
                    continue;
                  } catch (error) {
                    // File doesn't exist, continue
                  }
                  
                  // Determine import type
                  const hasDefaultExport = content.includes(`export default ${fileName}`) || 
                                        content.includes('export default function') ||
                                        content.includes('export default class') ||
                                        content.includes('export default (') ||
                                        content.includes('export default const');
                  
                  const importStatement = hasDefaultExport
                    ? `import ${fileName} from './${fileName}';`
                    : `import { ${fileName} } from './${fileName}';`;
                  
                  const category = relativePath.split(path.sep)[0] || 'General';
                  
                  const storyTemplate = `import React from 'react';
          ${importStatement}
          
          export default {
            title: '${category}/${fileName}',
            component: ${fileName},
            parameters: {
              componentSubtitle: 'Component from ${relativePath}'
            }
          };
          
          export const Default = {
            args: {}
          };`;
                  
                  await fs.writeFile(storyFilePath, storyTemplate);
                  console.log(`âœ“ Created story for ${fileName}`);
                  storiesGenerated++;
                  
                } catch (error) {
                  console.log(`Error processing ${filePath}: ${error.message}`);
                }
              }
              
              // Create dummy story if needed
              if (storiesGenerated === 0) {
                const dummyStoryPath = path.join(SRC_DIR, 'dummy.stories.jsx');
                const dummyStory = `
          import React from 'react';
          
          const Dummy = () => <div>This is a placeholder component to ensure Storybook loads correctly</div>;
          
          export default {
            title: 'Placeholder/Dummy',
            component: Dummy,
          };
          
          export const Default = {};
          `;
                await fs.writeFile(dummyStoryPath, dummyStory);
                console.log('Created dummy story for fallback');
                storiesGenerated = 1;
              }
              
              console.log(`âœ… Story generation complete!`);
              console.log(`Generated ${storiesGenerated} stories`);
              
            } catch (error) {
              console.error(`Error in story generation: ${error.message}`);
              console.error(error.stack);
              process.exit(1);
            }
          }
          
          generateStories();
          EOF
          
          # Delete the problematic story files
          rm -f src/AdminBulakSmartConnect/AccountManagementComponents/NewUserInfo.stories.jsx
          rm -f src/UserBulakSmartConnect/ApplicationComponents/ApplicationData.stories.jsx
          rm -f src/UserBulakSmartConnect/ApplicationComponents/BirthCertificateApplications/BirthCertificateApplicationData.stories.jsx
          
          # Install necessary packages
          npm install --no-save glob
          
          # Run the improved generator
          node generate-stories.mjs

      - name: Check for generated stories
        run: |
          cd bulak-smart-connect-js
          echo "=== Story files in project ==="
          find src -name "*.stories.*" | sort
          echo "=== Number of story files: $(find src -name "*.stories.*" | wc -l) ==="
          
          # Show content of a sample story file if any exist
          SAMPLE=$(find src -name "*.stories.*" | head -n 1)
          if [ -n "$SAMPLE" ]; then
            echo "=== Sample story file content ==="
            cat "$SAMPLE"
          else
            echo "No story files found!"
          fi

      - name: Build Storybook
        run: |
          cd bulak-smart-connect-js
          npx storybook build --output-dir storybook-static
      
      - name: Add .nojekyll file
        run: |
          cd bulak-smart-connect-js
          touch storybook-static/.nojekyll
      
      - name: Deploy Storybook
        uses: JamesIves/github-pages-deploy-action@v4
        with:
          folder: bulak-smart-connect-js/storybook-static
          target-folder: frontend-docs
          branch: gh-pages
          clean: true
          clean-exclude: |
            .nojekyll
            api-docs/**

      - name: Update documentation hub
        run: |
          mkdir -p doc_hub
          touch doc_hub/.nojekyll
          
          cat > doc_hub/index.html << 'EOF'
          <!DOCTYPE html>
          <html>
            <head>
              <meta charset="utf-8">
              <title>Bulak Smart Connect Documentation Hub</title>
              <style>
                body { 
                  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
                  max-width: 800px;
                  margin: 0 auto;
                  padding: 20px;
                  line-height: 1.6;
                }
                .header {
                  text-align: center;
                  padding: 20px 0;
                  margin-bottom: 40px;
                  border-bottom: 1px solid #eaeaea;
                }
                .header h1 {
                  color: #184a5b;
                  margin-bottom: 10px;
                }
                .card {
                  border: 1px solid #e0e0e0;
                  border-radius: 8px;
                  padding: 24px;
                  margin-bottom: 24px;
                  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                  transition: transform 0.2s, box-shadow 0.2s;
                }
                .card:hover {
                  transform: translateY(-2px);
                  box-shadow: 0 4px 8px rgba(0,0,0,0.1);
                }
                .card h2 {
                  margin-top: 0;
                  color: #184a5b;
                }
                .button {
                  display: inline-block;
                  background-color: #184a5b;
                  color: white;
                  padding: 10px 20px;
                  text-decoration: none;
                  border-radius: 4px;
                  margin-top: 10px;
                  font-weight: 500;
                  transition: background-color 0.2s;
                }
                .button:hover {
                  background-color: #0d3446;
                }
                .footer {
                  text-align: center;
                  color: #666;
                  margin-top: 40px;
                  padding-top: 20px;
                  border-top: 1px solid #eaeaea;
                  font-size: 0.9em;
                }
              </style>
            </head>
            <body>
              <div class="header">
                <h1>Bulak Smart Connect</h1>
                <p>Comprehensive Documentation Hub</p>
              </div>
              
              <div class="card">
                <h2>API Documentation</h2>
                <p>Backend API documentation generated with Compodoc, providing detailed information about endpoints, services, and models.</p>
                <a href="api-docs/" class="button">View API Docs</a>
              </div>
              
              <div class="card">
                <h2>Component Documentation</h2>
                <p>Frontend component documentation built with Storybook, including live examples, props documentation, and usage guides.</p>
                <a href="frontend-docs/" class="button">View Components</a>
              </div>
              
              <div class="footer">
                <p>Â© $(date +%Y) Bulak Smart Connect</p>
              </div>
            </body>
          </html>
          EOF
          
      - name: Deploy documentation hub
        uses: JamesIves/github-pages-deploy-action@v4
        with:
          folder: doc_hub
          branch: gh-pages
          clean: false